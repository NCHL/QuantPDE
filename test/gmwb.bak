////////////////////////////////////////////////////////////////////////////////
// gmwb.bak
// --------
//
// Routines that are no longer in use for the guaranteed minimum withdrawal
// benefit (GMWB) variable annuity pricing problem.
//
// Author: Parsiad Azimzadeh
////////////////////////////////////////////////////////////////////////////////

// This has been superceeded by the more general Impulse class.

class ImpulseWithdrawal final : public RawControlledLinearSystem2_1 {

	const RectilinearGrid2 &grid;
	Noncontrollable2 kappa;

public:

	template <typename G, typename F1>
	ImpulseWithdrawal(
		G &grid,
		F1 &&kappa
	) noexcept :
		grid(grid),
		kappa(kappa)
	{
	}

	virtual Matrix A(Real t) {
		Matrix M = grid.matrix();
		M.reserve(IntegerVector::Constant(grid.size(), 4));

		Index k = 0;
		const Vector &raw = control(0);

		for(auto node : grid) {
			const Real W = node[0]; // Investment
			const Real A = node[1]; // Withdrawal

			// Amount withdrawn pre-penalty
			const Real gamma = raw(k) * A;

			const Real Wplus = max(W - gamma, 0.);
			const Real Aplus = A - gamma;

			// Interpolation data
			auto data = linearInterpolationData(grid,
					{{Wplus,Aplus}});

			const Index i0 = std::get<0>( data[0] );
			const Index i1 = std::get<0>( data[1] );
			const Real  w0 = std::get<1>( data[0] );
			const Real  w1 = std::get<1>( data[1] );

			assert( (grid[0][i0+1] - Wplus)
					/ (grid[0][i0+1] - grid[0][i0]) == w0 );
			assert( (grid[1][i1+1] - Aplus)
					/ (grid[1][i1+1] - grid[1][i1]) == w1 );

			const Index j = grid.index(i0, i1);

			M.insert(k, j                     ) =    w0  *    w1 ;
			M.insert(k, j     + grid[0].size()) =    w0  * (1-w1);
			M.insert(k, j + 1                 ) = (1-w0) *    w1 ;
			M.insert(k, j + 1 + grid[0].size()) = (1-w0) * (1-w1);

			++k;
		}

		M.makeCompressed();
		return grid.identity() - M;
	}

	virtual Vector b(Real t) {
		Vector b = grid.vector();

		Index k = 0;
		const Vector &raw = control(0);

		for(auto node : accessor(grid, b)) {
			auto WA = &node;
			const Real W = WA[0]; // Investment
			const Real A = WA[1]; // Withdrawal

			// Amount withdrawn, pre-penalty
			const Real gamma = raw(k) * A;

			// Cashflow minus adjustment
			*node = (1 - kappa(t, W, A)) * gamma;

			++k;
		}

		return b;
	}

};

////////////////////////////////////////////////////////////////////////////////

// This results in a nonomonotone scheme and should not be used
// (testing purposes only)

class ContinuousWithdrawal final : public RawControlledLinearSystem2_1 {

	const RectilinearGrid2 &grid;
	Noncontrollable2 contractRate;

public:

	template <typename G, typename F1>
	ContinuousWithdrawal(
		G &grid,
		F1 &&contractRate
	) noexcept :
		grid(grid),
		contractRate(contractRate)
	{
	}

	virtual Matrix A(Real t) {
		Matrix M = grid.matrix();
		M.reserve(IntegerVector::Constant(grid.size(), 4));

		const Axis &W = grid[0];
		const Axis &A = grid[1];

		// Control as a vector
		Index k = W.size();
		const Vector &raw = control(0);

		// A > 0
		for(Index j = 1; j < A.size(); ++j) {
			// W = 0
			{
				const Real G  = contractRate(t, W[0], A[j]);
				const Real g = raw(k) * G;

				const Real tA = g / (A[j] - A[j-1]);

				M.insert(k, k           ) = +tA;
				M.insert(k, k - W.size()) = -tA;

				++k;
			}

			#if 0
			// W > 0
			for(Index i = 1; i < W.size(); ++i) {
				const Real G  = contractRate(t, W[i], A[j]);
				const Real g = raw(k) * G;

				const Real tA = g / (A[j] - A[j-1]);
				const Real tW = g / (W[i] - W[i-1]);

				M.insert(k, k           ) = + tA + tW;
				M.insert(k, k - W.size()) = - tA     ;
				M.insert(k, k - 1       ) =      - tW;

				++k;
			}
			#endif

			//#if 0
			// 0 < W < W_max
			for(Index i = 1; i < W.size() - 1; ++i) {
				const Real G  = contractRate(t, W[i], A[j]);
				const Real g = raw(k) * G;

				const Real tA = g / (A[j  ] - A[j-1]);
				const Real tW = g / (W[i+1] - W[i-1]);

				M.insert(k, k + 1       ) =      + tW;
				M.insert(k, k           ) = + tA     ;
				M.insert(k, k - W.size()) = - tA     ;
				M.insert(k, k - 1       ) =      - tW;

				++k;
			}

			// W = W_max
			{
				const Index i = W.size() - 1;

				const Real G  = contractRate(t, W[i], W[j]);
				const Real g = raw(k) * G;

				const Real tA = g / (A[j] - A[j-1]);
				const Real tW = g / (W[i] - W[i-1]);

				M.insert(k, k           ) = + tA + tW;
				M.insert(k, k - W.size()) = - tA     ;
				M.insert(k, k - 1       ) =      - tW;

				++k;
			}
			//#endif
		}

		M.makeCompressed();
		return M;
	}

	virtual Vector b(Real t) {
		Vector b = grid.vector();

		const Axis &W = grid[0];
		const Axis &A = grid[1];

		// Control as a vector
		Index k = 0;
		const Vector &raw = control(0);

		// A = 0 (no withdrawal)
		for(Index i = 0; i < W.size(); ++i) {
			b(k) = 0.;
			++k;
		}

		// A > 0
		for(Index j = 1; j < A.size(); ++j) {
			// W >= 0
			for(Index i = 0; i < W.size(); ++i) {
				const Real G = contractRate(t, W[i], A[j]);
				const Real g = raw(k) * G;
				b(k) = g;
				++k;
			}
		}

		return b;
	}

};

////////////////////////////////////////////////////////////////////////////////

// Use this in lieu of linear interpolation for a smoother convergence rate for
// the first few iterates

class WithdrawalEvent final : public EventBase {

	const RectilinearGrid2 &grid;
	const Real Gdt, kappa;

	template <typename V>
	Vector _doEvent(V &&Vp) const {
		// Interpolant
		PiecewiseLinear2 Vplus(grid, Vp);

		// Solution before withdrawal
		Vector Vm = grid.vector();

		// Axes
		const Axis &W = grid[0];
		const Axis &A = grid[1];

		assert(W[0] == 0.);
		assert(A[0] == 0.);

		// Minimum withdrawal amount (exclusive)
		Real L;
		if(method & SEMI_LAGRANGIAN_WITHDRAWAL_CONTINUOUS) {
			// Continuous withdrawal is handled here
			L = 0.;
		} else {
			// Continuous withdrawal is not handled here
			L = Gdt;
		}

		Index k = 0;
		for(Index j = 0; j < A.size(); ++j) {

			// Maximum withdrawal amount (inclusive)
			Real U;
			if(method & SEMI_LAGRANGIAN_WITHDRAWAL_IMPULSE) {
				// Impulse withdrawal is handled here
				U = A[j];
			} else {
				// Impulse withdrawal is not handled here
				U = min(A[j], Gdt);
			}

			for(Index i = 0; i < W.size(); ++i) {

				// Find the optimal control at this node

				// No withdrawal
				Real best = Vp(k);

				// Withdrawal at the contract rate
				if(
					method
					& SEMI_LAGRANGIAN_WITHDRAWAL_CONTINUOUS
				) {
					const Real beta = min(A[j], Gdt);

					const Real newValue =
							Vminus(
								Vplus,
								0.,
								W[i], A[j],
								beta / A[j]
							)
							+ cashflowD(
								0.,
								W[i], A[j],
								beta / A[j],
								Gdt
							)
					;

					if(newValue > best) {
						best = newValue;
					}
				}

				// Full surrender at penalty
				if(
					(A[j] > Gdt) && (method
					& SEMI_LAGRANGIAN_WITHDRAWAL_IMPULSE)
				) {
					const Real newValue =
							Vminus(
								Vplus,
								0.,
								W[i], A[j],
								1.
							)
							+ cashflowD(
								0.,
								W[i], A[j],
								1.,
								Gdt
							)
					;

					if(newValue > best) {
						best = newValue;
					}
				}

				// Withdraw <= W[i] (along W axis)
				for(Index ii = i; ii >= 0; --ii) {
					// Amount withdrawn (pre-penalty)
					const Real gamma = W[i] - W[ii];

					// Skip anything outside the bounds
					// TODO: Binary search to find starting
					//       point instead
					if( gamma <= L ) { continue; }
					if( gamma >  U ) {    break; }

					// Interpolate on the A axis
					const Real Ap = Aplus(
						0.,
						W[i], A[j],
						gamma / A[j]
					);
					auto data = linearInterpolationData(A,
							Ap);

					const Index jj = get<0>(data);
					const Real   w = get<1>(data);

					const Real newValue =
						     w *Vp(ii+ jj   *W.size())
						+ (1-w)*Vp(ii+(jj+1)*W.size())
						+ cashflowD(
							0.,
							W[ii], A[jj],
							gamma / A[jj],
							Gdt
						);
					;

					if(newValue > best) {
						best = newValue;
					}
				}

				// Withdraw > W[i]
				/*
				if(A[j] > W[i]) {
					const Real Alast = A[j] - W[i];

					for(Index jj = 0; A[jj] < Alast; ++jj) {
						// Amount withdrawn
						const Real gamma = A[j] - A[jj];

						const Real newValue =
							  Vp(jj * W.size())
							+ cashflowD(
								0.,
								W[ii], A[jj]
								gamma / A[jj],
								Gdt
							)
						;

						if(newValue > best) {
							best = newValue;
						}
					}
				}
				*/

				// Withdraw <= A[j] (along A axis)
				for(Index jj = j; jj >= 0; --jj) {
					// Amount withdrawn pre-penalty
					const Real gamma = A[j] - A[jj];

					// Skip anything outside the bounds
					// TODO: Binary search to find starting
					//       point instead
					if( gamma <= L ) { continue; }
					if( gamma >  U ) {    break; }

					// Interpolate on the W axis
					const Real Wp = Wplus(
						0.,
						W[i], A[j],
						gamma / A[j]
					);
					auto data = linearInterpolationData(W,
							Wp);

					const Index ii = get<0>(data);
					const Real   w = get<1>(data);

					const Real newValue =
						     w *Vp( ii   +jj*W.size())
						+ (1-w)*Vp((ii+1)+jj*W.size())
						+ cashflowD(
							0.,
							W[ii], A[jj],
							gamma / A[jj],
							Gdt
						);
					;

					if(newValue > best) {
						best = newValue;
					}
				}

				Vm(k++) = best;
			}
		}

		return Vm;
	}

	virtual Vector doEvent(const Vector &vector) const {
		return _doEvent(vector);
	}

	virtual Vector doEvent(Vector &&vector) const {
		return _doEvent(move(vector));
	}

public:

	template <typename G>
	WithdrawalEvent(
		G &&grid,
		Real Gdt,
		Real kappa
	) noexcept :
		grid(grid),
		Gdt(Gdt),
		kappa(kappa)
	{
	}

};
